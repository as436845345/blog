<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于向量的线段箭头绘制详解</title>
      <link href="/2026/02/20/vector-based-arrow-rendering-for-line-segments-md/"/>
      <url>/2026/02/20/vector-based-arrow-rendering-for-line-segments-md/</url>
      
        <content type="html"><![CDATA[<h3 id="最后更新时间：2026-02-20-21-08-05"><a href="#最后更新时间：2026-02-20-21-08-05" class="headerlink" title="最后更新时间：2026-02-20 21:08:05"></a><strong>最后更新时间：2026-02-20 21:08:05</strong></h3><p>本文通过豆包辅助生成！</p><hr><p>本文将详细解析如何通过向量运算在 SkiaSharp 中为线段绘制箭头，并系统讲解过程中涉及的向量数学原理与实现逻辑。</p><h2 id="一、核心需求概述"><a href="#一、核心需求概述" class="headerlink" title="一、核心需求概述"></a>一、核心需求概述</h2><p>你希望通过向量运算，在 SkiaSharp 的绘制场景中，为任意线段的端点（示例中为 startPos 到 endPos 的线段终点）绘制标准的箭头样式，核心是利用向量的减法、归一化、法向量、缩放、加法等运算实现箭头两个斜边的精准定位。</p><h2 id="二、向量基础定义"><a href="#二、向量基础定义" class="headerlink" title="二、向量基础定义"></a>二、向量基础定义</h2><h3 id="1-二维向量结构体（PEVector）"><a href="#1-二维向量结构体（PEVector）" class="headerlink" title="1. 二维向量结构体（PEVector）"></a>1. 二维向量结构体（PEVector）</h3><p>示例中定义了 PEVector 结构体来封装二维向量的属性与核心运算，核心属性和方法如下：</p><table><thead><tr><th>成员</th><th>说明</th><th>数学表达</th></tr></thead><tbody><tr><td>X&#x2F;Y</td><td>向量的x、y分量</td><td>向量 $\vec{v} &#x3D; (X, Y)$</td></tr><tr><td>Length</td><td>向量的模（长度）</td><td>$|\vec{v}| &#x3D; \sqrt{X^2 + Y^2}$</td></tr><tr><td>Normalize()</td><td>向量归一化（转为单位向量）</td><td>$\hat{v} &#x3D; \frac{\vec{v}}{|\vec{v}|}$</td></tr><tr><td>GetNormal()</td><td>获取向量的法向量</td><td>若 $\vec{v}&#x3D;(x,y)$，则法向量为 $(y, -x)$</td></tr><tr><td>Add(v1, v2)</td><td>向量加法</td><td>$\vec{v_1} + \vec{v_2} &#x3D; (x_1+x_2, y_1+y_2)$</td></tr><tr><td>Sub(v1, v2)</td><td>向量减法</td><td>$\vec{v_1} - \vec{v_2} &#x3D; (x_1-x_2, y_1-y_2)$</td></tr><tr><td>Scale(v, s)</td><td>向量缩放</td><td>$s \cdot \vec{v} &#x3D; (s \cdot x, s \cdot y)$</td></tr></tbody></table><h3 id="2-向量关键概念补充"><a href="#2-向量关键概念补充" class="headerlink" title="2. 向量关键概念补充"></a>2. 向量关键概念补充</h3><ul><li><strong>单位向量</strong>：模为 1 的向量，仅表示方向，无长度属性，公式：$\hat{v} &#x3D; \frac{\vec{v}}{|\vec{v}|}$（要求 $|\vec{v}| \neq 0$）。</li><li><strong>法向量</strong>：与原向量垂直的向量，二维向量 $(x,y)$ 有两个正交法向量：$(y, -x)$ 和 $(-y, x)$（两者方向相反）。</li><li><strong>向量减法几何意义</strong>：$\vec{v_1} - \vec{v_2}$ 表示从 $v_2$ 指向 $v_1$ 的向量。</li></ul><h2 id="三、箭头绘制完整流程（附数学公式）"><a href="#三、箭头绘制完整流程（附数学公式）" class="headerlink" title="三、箭头绘制完整流程（附数学公式）"></a>三、箭头绘制完整流程（附数学公式）</h2><p>以下按代码执行顺序，拆解箭头绘制的每一步逻辑与对应的数学运算：</p><h3 id="步骤1：定义基础参数与线段起点-终点"><a href="#步骤1：定义基础参数与线段起点-终点" class="headerlink" title="步骤1：定义基础参数与线段起点&#x2F;终点"></a>步骤1：定义基础参数与线段起点&#x2F;终点</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> Gap = <span class="number">10</span>; <span class="comment">// 箭头斜边的长度（像素）</span></span><br><span class="line"><span class="keyword">var</span> startPos = <span class="keyword">new</span> PEVector(<span class="number">200</span>, <span class="number">600</span>); <span class="comment">// 线段起点 S(200,600)</span></span><br><span class="line"><span class="keyword">var</span> endPos = <span class="keyword">new</span> PEVector(<span class="number">600</span>, <span class="number">200</span>);   <span class="comment">// 线段终点 E(600,200)</span></span><br><span class="line">canvas.DrawLine(startPos.ToSKPoint(), endPos.ToSKPoint(), linePaint); <span class="comment">// 绘制基础线段</span></span><br></pre></td></tr></table></figure><p>基础线段为：从点 $S(x_s, y_s)$ 到点 $E(x_e, y_e)$ 的直线段。</p><h3 id="步骤2：计算线段的方向向量"><a href="#步骤2：计算线段的方向向量" class="headerlink" title="步骤2：计算线段的方向向量"></a>步骤2：计算线段的方向向量</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> direction = PEVector.Sub(endPos, startPos); <span class="comment">// 从起点指向终点的方向向量</span></span><br></pre></td></tr></table></figure><p>数学公式：<br>$$\vec{direction} &#x3D; E - S &#x3D; (x_e - x_s, y_e - y_s)$$<br>几何意义：该向量完全表示线段SE的方向和长度。</p><h3 id="步骤3：将方向向量归一化（转为单位向量）"><a href="#步骤3：将方向向量归一化（转为单位向量）" class="headerlink" title="步骤3：将方向向量归一化（转为单位向量）"></a>步骤3：将方向向量归一化（转为单位向量）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">direction.Normalize(); <span class="comment">// 归一化得到单位方向向量</span></span><br></pre></td></tr></table></figure><p>数学公式：<br>$$\hat{direction} &#x3D; \frac{\vec{direction}}{|\vec{direction}|} &#x3D; \frac{(x_e - x_s, y_e - y_s)}{\sqrt{(x_e - x_s)^2 + (y_e - y_s)^2}}$$<br>作用：消除长度影响，仅保留方向信息，方便后续按固定长度（Gap）偏移。</p><h3 id="步骤4：计算箭头中心点（箭头斜边的交汇起点）"><a href="#步骤4：计算箭头中心点（箭头斜边的交汇起点）" class="headerlink" title="步骤4：计算箭头中心点（箭头斜边的交汇起点）"></a>步骤4：计算箭头中心点（箭头斜边的交汇起点）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> endHeadCenter = PEVector.Sub(endPos, PEVector.Scale(direction, Gap));</span><br></pre></td></tr></table></figure><p>数学公式：<br>$$P_{center} &#x3D; E - Gap \cdot \hat{direction}$$<br>几何意义：从线段终点 E，沿着线段反方向（-$\hat{direction}$）移动 Gap 像素，得到箭头的中心点 $P_{center}$，箭头的两个斜边将从该点向E的左右两侧延伸。</p><h3 id="步骤5：计算左侧斜边的端点"><a href="#步骤5：计算左侧斜边的端点" class="headerlink" title="步骤5：计算左侧斜边的端点"></a>步骤5：计算左侧斜边的端点</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取方向向量的法向量（左方向）</span></span><br><span class="line"><span class="keyword">var</span> directionToLeft = direction.GetNormal(); </span><br><span class="line"><span class="comment">// 计算左侧端点：中心点 + 左法向量×Gap</span></span><br><span class="line"><span class="keyword">var</span> leftEndHeadPos = PEVector.Add(endHeadCenter, PEVector.Scale(directionToLeft, Gap));</span><br><span class="line"><span class="comment">// 绘制左侧斜边（从左端点到终点E）</span></span><br><span class="line">canvas.DrawLine(leftEndHeadPos.ToSKPoint(), endPos.ToSKPoint(), linePaint);</span><br></pre></td></tr></table></figure><p>数学公式：<br>$$\vec{n_{left}} &#x3D; (y_{\hat{direction}}, -x_{\hat{direction}}) \quad \text{（左法向量）}$$<br>$$P_{left} &#x3D; P_{center} + Gap \cdot \vec{n_{left}}$$<br>几何意义：左法向量与原方向向量垂直，沿该方向偏移 Gap 像素，得到箭头左侧斜边的端点 $P_{left}$，连接 $P_{left}$ 和 E 即箭头左斜边。</p><h3 id="步骤6：计算右侧斜边的端点"><a href="#步骤6：计算右侧斜边的端点" class="headerlink" title="步骤6：计算右侧斜边的端点"></a>步骤6：计算右侧斜边的端点</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取方向向量的右法向量（左法向量取反）</span></span><br><span class="line"><span class="keyword">var</span> directionToRight = PEVector.Scale(direction.GetNormal(), <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 计算右侧端点：中心点 + 右法向量×Gap</span></span><br><span class="line"><span class="keyword">var</span> rightEndHeadPos = PEVector.Add(endHeadCenter, PEVector.Scale(directionToRight, Gap));</span><br><span class="line"><span class="comment">// 绘制右侧斜边（从右端点到终点E）</span></span><br><span class="line">canvas.DrawLine(rightEndHeadPos.ToSKPoint(), endPos.ToSKPoint(), linePaint);</span><br></pre></td></tr></table></figure><p>数学公式：<br>$$\vec{n_{right}} &#x3D; -\vec{n_{left}} &#x3D; (-y_{\hat{direction}}, x_{\hat{direction}}) \quad \text{（右法向量）}$$<br>$$P_{right} &#x3D; P_{center} + Gap \cdot \vec{n_{right}}$$<br>几何意义：右法向量与左法向量方向相反，沿该方向偏移 Gap 像素，得到箭头右侧斜边的端点 $P_{right}$，连接 $P_{right}$ 和 E 即箭头右斜边。</p><h3 id="步骤7（可选）：绘制辅助定位圆"><a href="#步骤7（可选）：绘制辅助定位圆" class="headerlink" title="步骤7（可选）：绘制辅助定位圆"></a>步骤7（可选）：绘制辅助定位圆</h3><p>通过绘制红&#x2F;绿色小圆标记关键点位（$P_{center}$、$P_{left}$、$P_{right}$），便于调试箭头位置：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ShowCircle)</span><br><span class="line">&#123;</span><br><span class="line">    canvas.DrawCircle(endHeadCenter.ToSKPoint(), <span class="number">3</span>, <span class="keyword">new</span> SKPaint &#123; Color = SKColors.Red &#125;); <span class="comment">// 中心点（红）</span></span><br><span class="line">    canvas.DrawCircle(leftEndHeadPos.ToSKPoint(), <span class="number">3</span>, <span class="keyword">new</span> SKPaint &#123; Color = SKColors.Green &#125;); <span class="comment">// 左端点（绿）</span></span><br><span class="line">    canvas.DrawCircle(rightEndHeadPos.ToSKPoint(), <span class="number">3</span>, <span class="keyword">new</span> SKPaint &#123; Color = SKColors.Green &#125;); <span class="comment">// 右端点（绿）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、完整代码整合"><a href="#四、完整代码整合" class="headerlink" title="四、完整代码整合"></a>四、完整代码整合</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SkiaSharp;</span><br><span class="line"><span class="keyword">using</span> SkiaSharp.Views.Desktop;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> PEVector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PEVector</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PEVector</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量的模（长度）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">double</span> Length =&gt; Math.Sqrt(X * X + Y * Y);</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 归一化：将向量转为单位向量（模≈1）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Normalize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> length = Length;</span><br><span class="line">        <span class="keyword">if</span> (length &lt; <span class="number">1e-9</span>) <span class="keyword">return</span>; <span class="comment">// 避免除以0</span></span><br><span class="line">        X /= length;</span><br><span class="line">        Y /= length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取向量的法向量（垂直向量）：(x,y) → (y, -x)</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PEVector <span class="title">GetNormal</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PEVector &#123; X = Y, Y = -X &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 向量加法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PEVector <span class="title">Add</span>(<span class="params">PEVector v1, PEVector v2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PEVector &#123; X = v1.X + v2.X, Y = v1.Y + v2.Y &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 向量减法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PEVector <span class="title">Sub</span>(<span class="params">PEVector v1, PEVector v2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PEVector &#123; X = v1.X - v2.X, Y = v1.Y - v2.Y &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 向量缩放</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PEVector <span class="title">Scale</span>(<span class="params">PEVector v, <span class="built_in">double</span> scale</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PEVector &#123; X = v.X * scale, Y = v.Y * scale &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">PEVectorExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 向量转为SkiaSharp的点</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SKPoint <span class="title">ToSKPoint</span>(<span class="params"><span class="keyword">this</span> PEVector v</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SKPoint((<span class="built_in">float</span>)v.X, (<span class="built_in">float</span>)v.Y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ArrowDrawing</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SKElement_PaintSurface</span>(<span class="params"><span class="built_in">object</span> sender, SKPaintSurfaceEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">int</span> Gap = <span class="number">10</span>; <span class="comment">// 箭头尺寸（像素）</span></span><br><span class="line">        <span class="built_in">bool</span> ShowCircle = <span class="literal">false</span>; <span class="comment">// 是否显示辅助定位圆</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> canvas = e.Surface.Canvas;</span><br><span class="line">        canvas.Clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化画笔</span></span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> linePaint = <span class="keyword">new</span> SKPaint &#123; Color = SKColors.Black, StrokeWidth = <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 定义线段起点和终点</span></span><br><span class="line">        <span class="keyword">var</span> startPos = <span class="keyword">new</span> PEVector(<span class="number">200</span>, <span class="number">600</span>);</span><br><span class="line">        <span class="keyword">var</span> endPos = <span class="keyword">new</span> PEVector(<span class="number">600</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 绘制基础线段</span></span><br><span class="line">        canvas.DrawLine(startPos.ToSKPoint(), endPos.ToSKPoint(), linePaint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 计算从起点到终点的方向向量</span></span><br><span class="line">        <span class="keyword">var</span> direction = PEVector.Sub(endPos, startPos);</span><br><span class="line">        <span class="comment">// 3. 归一化方向向量（转为单位向量）</span></span><br><span class="line">        direction.Normalize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 计算箭头中心点（从终点反方向偏移Gap）</span></span><br><span class="line">        <span class="keyword">var</span> endHeadCenter = PEVector.Sub(endPos, PEVector.Scale(direction, Gap));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 计算箭头左侧斜边端点并绘制</span></span><br><span class="line">        <span class="keyword">var</span> directionToLeft = direction.GetNormal(); <span class="comment">// 左法向量</span></span><br><span class="line">        <span class="keyword">var</span> leftEndHeadPos = PEVector.Add(endHeadCenter, PEVector.Scale(directionToLeft, Gap));</span><br><span class="line">        canvas.DrawLine(leftEndHeadPos.ToSKPoint(), endPos.ToSKPoint(), linePaint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 计算箭头右侧斜边端点并绘制</span></span><br><span class="line">        <span class="keyword">var</span> directionToRight = PEVector.Scale(direction.GetNormal(), <span class="number">-1</span>); <span class="comment">// 右法向量</span></span><br><span class="line">        <span class="keyword">var</span> rightEndHeadPos = PEVector.Add(endHeadCenter, PEVector.Scale(directionToRight, Gap));</span><br><span class="line">        canvas.DrawLine(rightEndHeadPos.ToSKPoint(), endPos.ToSKPoint(), linePaint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可选：绘制辅助定位圆</span></span><br><span class="line">        <span class="keyword">if</span> (ShowCircle)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> redPaint = <span class="keyword">new</span> SKPaint &#123; Color = SKColors.Red, StrokeWidth = <span class="number">1</span>, Style = SKPaintStyle.Fill &#125;;</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> greenPaint = <span class="keyword">new</span> SKPaint &#123; Color = SKColors.Green, StrokeWidth = <span class="number">1</span>, Style = SKPaintStyle.Fill &#125;;</span><br><span class="line">            canvas.DrawCircle(endHeadCenter.ToSKPoint(), <span class="number">3</span>, redPaint);</span><br><span class="line">            canvas.DrawCircle(leftEndHeadPos.ToSKPoint(), <span class="number">3</span>, greenPaint);</span><br><span class="line">            canvas.DrawCircle(rightEndHeadPos.ToSKPoint(), <span class="number">3</span>, greenPaint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><strong>核心向量运算</strong>：箭头绘制的关键是通过<strong>向量减法</strong>获取方向、<strong>归一化</strong>消除长度影响、<strong>法向量</strong>获取垂直方向、<strong>缩放+加法</strong>实现点位偏移；</li><li><strong>关键公式</strong>：<ul><li>方向向量：$\vec{direction} &#x3D; E - S$</li><li>单位向量：$\hat{direction} &#x3D; \vec{direction} &#x2F; |\vec{direction}|$</li><li>箭头中心点：$P_{center} &#x3D; E - Gap \cdot \hat{direction}$</li><li>左右端点：$P_{left&#x2F;right} &#x3D; P_{center} ± Gap \cdot (y_{\hat{direction}}, -x_{\hat{direction}})$；</li></ul></li><li><strong>扩展建议</strong>：可通过调整 Gap 参数控制箭头大小，若需为线段起点绘制箭头，仅需反转方向向量的计算逻辑（$\vec{direction} &#x3D; S - E$）即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> Vector </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> SkiaSharp </tag>
            
            <tag> Vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尽量使用 stackalloc 表达式</title>
      <link href="/2026/01/24/perfer-stackalloc-usage/"/>
      <url>/2026/01/24/perfer-stackalloc-usage/</url>
      
        <content type="html"><![CDATA[<h3 id="最后更新时间：2026-02-20-19-54-51"><a href="#最后更新时间：2026-02-20-19-54-51" class="headerlink" title="最后更新时间：2026-02-20 19:54:51"></a><strong>最后更新时间：2026-02-20 19:54:51</strong></h3><p>本文通过豆包+ChatGpt辅助生成！</p><hr><p>在 .NET 性能优化领域，stackalloc 是绕不开的核心关键词。它允许开发者<strong>直接在当前方法的栈帧上分配连续内存</strong>，彻底绕过 GC 管理、避免堆分配开销，更是 Span&lt;T&gt; 等高性能 API 的底层基石。</p><p>但 stackalloc 犹如一把“双刃剑”：用得好能成为性能飙升的利器，用不好则可能引发 StackOverflowException 或隐藏的生命周期 bug。本文将系统拆解其核心逻辑、优势、限制，并给出“栈+对象池”的推荐使用模式。</p><h2 id="一、stackalloc-核心概述"><a href="#一、stackalloc-核心概述" class="headerlink" title="一、stackalloc 核心概述"></a>一、stackalloc 核心概述</h2><h3 id="1-什么是-stackalloc？"><a href="#1-什么是-stackalloc？" class="headerlink" title="1. 什么是 stackalloc？"></a>1. 什么是 stackalloc？</h3><p>stackalloc 是 .NET 中的<strong>内存分配表达式</strong>，核心作用是在<strong>当前方法的调用栈（stack frame）上</strong>分配一段连续内存。</p><p>其核心语义（必须牢记）：</p><ul><li>分配位置：仅限当前线程的调用栈，而非托管堆；</li><li>生命周期：与当前方法绑定，方法执行完毕后，栈指针回退，内存自动释放；</li><li>释放方式：无需手动释放，也不允许显式释放；</li><li>GC 交互：完全不受 GC 管理，GC 无法感知这段内存；</li><li>内存固定：无需 fixed 关键字，栈内存天然不会被 GC 移动。</li></ul><p>这是它与 new T[] 堆分配的本质区别——堆分配需 GC 跟踪、回收，而栈分配是“即用即弃”的确定性内存操作。</p><h3 id="2-两种基本创建方式"><a href="#2-两种基本创建方式" class="headerlink" title="2. 两种基本创建方式"></a>2. 两种基本创建方式</h3><p>stackalloc 支持两种使用形式，语义层级和适用场景不同，现代开发更推荐第一种：</p><h4 id="2-1-Span-stackalloc（现代推荐）"><a href="#2-1-Span-stackalloc（现代推荐）" class="headerlink" title="2-1. Span + stackalloc（现代推荐）"></a>2-1. Span<T> + stackalloc（现代推荐）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Span&lt;<span class="built_in">int</span>&gt; buffer = <span class="keyword">stackalloc</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><ul><li>本质：在栈上分配 int[2] 数组，返回 Span&lt;T&gt; 作为内存视图；</li><li>优势：编译器强制生命周期安全检查，无需 unsafe 块，可在安全代码中使用；</li><li>适用场景：绝大多数高性能内存操作场景，是当前 .NET 推荐的主流用法。</li></ul><h4 id="2-2-裸指针形式（底层-不安全场景）"><a href="#2-2-裸指针形式（底层-不安全场景）" class="headerlink" title="2-2. 裸指针形式（底层&#x2F;不安全场景）"></a>2-2. 裸指针形式（底层&#x2F;不安全场景）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>* buffer = <span class="keyword">stackalloc</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本质：直接返回指向栈内存的裸指针（int*）；</li><li>风险：编译器不再做生命周期检查，极易出现<strong>悬垂指针（访问已释放的栈内存）</strong>；</li><li>适用场景：仅用于底层非托管交互、极致性能优化等特殊场景，需手动保证内存安全。</li></ul><blockquote><p>现代 .NET 开发共识：stackalloc 几乎总是与 Span&lt;T&gt; 配合使用，避免直接操作裸指针。</p></blockquote><h2 id="二、stackalloc-的核心优势"><a href="#二、stackalloc-的核心优势" class="headerlink" title="二、stackalloc 的核心优势"></a>二、stackalloc 的核心优势</h2><h3 id="1-彻底避免堆分配开销"><a href="#1-彻底避免堆分配开销" class="headerlink" title="1. 彻底避免堆分配开销"></a>1. 彻底避免堆分配开销</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Span&lt;<span class="built_in">byte</span>&gt; buffer = <span class="keyword">stackalloc</span> <span class="built_in">byte</span>[<span class="number">256</span>];</span><br></pre></td></tr></table></figure><p>这段代码不会产生任何堆分配相关的开销：</p><ul><li>无 newobj 指令（堆分配的核心指令）；</li><li>无 GC 跟踪成本（GC 无需记录这段内存）；</li><li>无对象代际晋升（堆分配的小对象易进入 Gen 0，触发频繁 GC）。</li></ul><p>对比堆分配（new byte[256]），栈分配省去了“查找堆空闲区域、写入对象头、零初始化内存”等步骤，在高频调用场景（如循环内创建临时缓冲区）中性能优势极其明显。</p><h3 id="2-与-Span-天然契合"><a href="#2-与-Span-天然契合" class="headerlink" title="2. 与 Span 天然契合"></a>2. 与 Span<T> 天然契合</h3><p>Span&lt;T&gt; 本身是 <code>ref struct</code> 类型，设计目标就是“安全操作连续内存”，其特性与 stackalloc 完美匹配：</p><ul><li>Span&lt;T&gt; 不能装箱、不能逃逸到堆、不能跨 async&#x2F;await；</li><li>编译器强制 Span&lt;T&gt; 的生命周期不超过其引用的内存（如栈内存）；</li><li>两者结合既保留了栈分配的高性能，又通过 Span&lt;T&gt; 的安全检查避免了内存风险。</li></ul><p>这种组合是 .NET 高性能内存操作的“黄金搭档”，广泛应用于 System.Text.Json、Socket、Pipelines 等底层 API 中。</p><h2 id="三、stackalloc-的限制与潜在风险"><a href="#三、stackalloc-的限制与潜在风险" class="headerlink" title="三、stackalloc 的限制与潜在风险"></a>三、stackalloc 的限制与潜在风险</h2><h3 id="1-栈空间有限，超大分配易溢出"><a href="#1-栈空间有限，超大分配易溢出" class="headerlink" title="1. 栈空间有限，超大分配易溢出"></a>1. 栈空间有限，超大分配易溢出</h3><p>这是 stackalloc 最常见也最危险的问题。以下代码会直接触发 StackOverflowException：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Span&lt;<span class="built_in">byte</span>&gt; buffer = <span class="keyword">stackalloc</span> <span class="built_in">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// ❌ 1MB 栈分配，远超栈容量</span></span><br></pre></td></tr></table></figure><p>核心原因：</p><ul><li>每个 .NET 线程的栈大小是固定的（默认 1MB~8MB，取决于操作系统和架构）；</li><li>栈空间并非仅用于 stackalloc 分配，还需容纳：方法局部变量、函数调用链、JIT 临时变量、ABI 内存对齐等；</li><li>即使是 512KB 的 stackalloc 分配，也可能因当前栈空间已被占用而溢出。</li></ul><h3 id="2-栈溢出是不可恢复的致命错误"><a href="#2-栈溢出是不可恢复的致命错误" class="headerlink" title="2. 栈溢出是不可恢复的致命错误"></a>2. 栈溢出是不可恢复的致命错误</h3><p>这是 stackalloc 与堆分配的关键区别：</p><ul><li>堆分配失败（OutOfMemoryException）：可通过 try-catch 捕获，程序有机会恢复；</li><li>栈溢出（StackOverflowException）：.NET 不允许捕获，直接导致<strong>进程终止</strong>。</li></ul><p>这意味着：一次未做限制的 stackalloc 调用，可能直接让整个应用崩溃。</p><h3 id="3-生命周期严格受限，无法跨场景传递"><a href="#3-生命周期严格受限，无法跨场景传递" class="headerlink" title="3. 生命周期严格受限，无法跨场景传递"></a>3. 生命周期严格受限，无法跨场景传递</h3><p>stackalloc 分配的内存生命周期与当前方法完全绑定，编译器会强制阻止“内存逃逸”：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Span&lt;<span class="built_in">int</span>&gt; <span class="title">GetStackAllocSpan</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Span&lt;<span class="built_in">int</span>&gt; buffer = <span class="keyword">stackalloc</span> <span class="built_in">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">return</span> buffer; <span class="comment">// ❌ 编译报错：无法返回指向栈内存的 Span</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的限制还包括：</p><ul><li>不能将栈内存的 Span&lt;T&gt; 存入类的字段；</li><li>不能在 lambda&#x2F;闭包 中捕获栈内存引用；</li><li>不能跨 async&#x2F;await 传递（异步方法会切换调用栈）。</li></ul><p>这些限制是编译器的“安全护栏”，避免开发者无意间使用已释放的栈内存。</p><h2 id="四、推荐模式：stackalloc-ArrayPool-组合使用"><a href="#四、推荐模式：stackalloc-ArrayPool-组合使用" class="headerlink" title="四、推荐模式：stackalloc + ArrayPool 组合使用"></a>四、推荐模式：stackalloc + ArrayPool 组合使用</h2><h3 id="1-组合的核心逻辑"><a href="#1-组合的核心逻辑" class="headerlink" title="1. 组合的核心逻辑"></a>1. 组合的核心逻辑</h3><p>现实开发中，临时缓冲区的大小往往不固定：</p><ul><li>小缓冲区（如 ≤ 1KB）：stackalloc 性能最优，无 GC 开销；</li><li>大缓冲区（如 &gt; 1KB）：栈空间不足，无法用 stackalloc；</li><li>直接 new T[]：高频调用会产生大量临时对象，引发 GC 压力。</li></ul><p>解决方案：<strong>小用栈，大用池</strong>——通过阈值区分，小缓冲区用 stackalloc，大缓冲区用 ArrayPool&lt;T&gt; 复用，兼顾性能与安全性。</p><h3 id="2-可直接复用的代码实现"><a href="#2-可直接复用的代码实现" class="headerlink" title="2. 可直接复用的代码实现"></a>2. 可直接复用的代码实现</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessBuffer</span>(<span class="params"><span class="built_in">int</span> length</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设定栈分配阈值（推荐 1024 字节，可根据场景调整）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> MAX_STACKALLOC_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span>[]? pooledArray = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 按长度选择分配方式：小尺寸栈分配，大尺寸对象池租借</span></span><br><span class="line">    Span&lt;<span class="built_in">int</span>&gt; buffer = length &lt;= MAX_STACKALLOC_SIZE </span><br><span class="line">        ? <span class="keyword">stackalloc</span> <span class="built_in">int</span>[length] </span><br><span class="line">        : (pooledArray = ArrayPool&lt;<span class="built_in">int</span>&gt;.Shared.Rent(length)).AsSpan();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑：安全操作 buffer（读写、切片等）</span></span><br><span class="line">        <span class="keyword">if</span> (buffer.Length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[<span class="number">0</span>] = <span class="number">42</span>;</span><br><span class="line">            <span class="comment">// ... 其他内存操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 关键：归还对象池数组，避免资源泄漏</span></span><br><span class="line">        <span class="keyword">if</span> (pooledArray != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ArrayPool&lt;<span class="built_in">int</span>&gt;.Shared.Return(pooledArray);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-模式背后的-NET-性能哲学"><a href="#3-模式背后的-NET-性能哲学" class="headerlink" title="3. 模式背后的 .NET 性能哲学"></a>3. 模式背后的 .NET 性能哲学</h3><p>这种“按尺寸选择分配策略”的模式，是 .NET 底层设计的核心哲学，在 BCL（基础类库）中被广泛应用：</p><table><thead><tr><th>缓冲区尺寸</th><th>分配策略</th><th>核心优势</th></tr></thead><tbody><tr><td>小（≤1KB）</td><td>stackalloc 栈分配</td><td>极致性能，无 GC 开销</td></tr><tr><td>中（1KB~100KB）</td><td>ArrayPool 复用</td><td>避免重复堆分配，控制 GC</td></tr><tr><td>大（&gt;100KB）</td><td>显式堆分配（new）</td><td>栈&#x2F;池不适合，直接堆分配更稳定</td></tr></tbody></table><p>你可以在 ValueStringBuilder、Utf8Formatter、System.Text.Json 等高性能组件中，看到完全一致的设计思路。</p><h2 id="五、总结与使用建议"><a href="#五、总结与使用建议" class="headerlink" title="五、总结与使用建议"></a>五、总结与使用建议</h2><h3 id="一句话总结-stackalloc"><a href="#一句话总结-stackalloc" class="headerlink" title="一句话总结 stackalloc"></a>一句话总结 stackalloc</h3><p>stackalloc 是 .NET 中<strong>用“严格生命周期限制”换取“极致性能”、用“确定性内存管理”换取“安全边界”的工具</strong>——适合特定场景，但绝非万能。</p><h3 id="适用场景（✅-推荐）"><a href="#适用场景（✅-推荐）" class="headerlink" title="适用场景（✅ 推荐）"></a>适用场景（✅ 推荐）</h3><ul><li>短生命周期的临时缓冲区（仅在当前方法内使用）；</li><li>高频调用的性能敏感场景（如循环内的小尺寸内存操作）；</li><li>与 Span&lt;T&gt; 配合，进行安全的内存读写、切片等操作。</li></ul><h3 id="不适用场景（❌-避免）"><a href="#不适用场景（❌-避免）" class="headerlink" title="不适用场景（❌ 避免）"></a>不适用场景（❌ 避免）</h3><ul><li>大尺寸内存分配（超过 1KB 需谨慎评估栈空间）；</li><li>长度不确定的内存需求（无法预判是否超出栈容量）；</li><li>需要跨方法、跨异步场景传递的内存；</li><li>普通业务代码随意使用（优先保证稳定性，而非极致性能）。</li></ul><p>stackalloc 不是“性能银弹”，但掌握其核心逻辑与组合模式后，能在关键场景中显著提升 .NET 应用的性能，同时规避潜在风险。</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> stackalloc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> stackalloc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Span&lt;T&gt;：灵活高效的可写内存操作</title>
      <link href="/2026/01/19/span-usage/"/>
      <url>/2026/01/19/span-usage/</url>
      
        <content type="html"><![CDATA[<h3 id="最后更新时间：2026-01-19-10-30-49"><a href="#最后更新时间：2026-01-19-10-30-49" class="headerlink" title="最后更新时间：2026-01-19 10:30:49"></a><strong>最后更新时间：2026-01-19 10:30:49</strong></h3><p>本文通过豆包辅助生成！</p><hr><!-- 这个是关于 ReadOnlySpan<T> 的文章，请生成一篇关于 Span<T> 的文章。因为 Span<T> 与 ReadOnlySpan<T> 大致相同，所以请描述 ReadOnlySpan<T> 没有的内容，讲解优势，并提供案例。 --><p>在 C# 高性能内存操作体系中，Span&lt;T&gt; 是 ReadOnlySpan&lt;T&gt; 的“可写版兄弟”——它继承了 ReadOnlySpan&lt;T&gt; 轻量、零拷贝、栈分配的核心优势，同时解锁了<strong>修改内存内容</strong>的能力，是高频读写场景下的核心工具。本文将从“与 ReadOnlySpan&lt;T&gt; 的差异、核心能力、使用教程、优势场景”四个维度，全面解析 Span&lt;T&gt; 的使用方式。</p><h2 id="一、Span-与-ReadOnlySpan-核心差异"><a href="#一、Span-与-ReadOnlySpan-核心差异" class="headerlink" title="一、Span&lt;T&gt; 与 ReadOnlySpan&lt;T&gt; 核心差异"></a>一、Span&lt;T&gt; 与 ReadOnlySpan&lt;T&gt; 核心差异</h2><p>Span&lt;T&gt; 和 ReadOnlySpan&lt;T&gt; 同属“内存跨度类型”，底层均为栈分配的内存视图，但核心区别在于<strong>可写性</strong>，具体差异如下表：</p><table><thead><tr><th>特性</th><th>ReadOnlySpan&lt;T&gt;</th><th>Span&lt;T&gt;</th></tr></thead><tbody><tr><td>内存操作权限</td><td>仅可读，无法修改内存内容</td><td>可读可写，支持修改内存原内容</td></tr><tr><td>类型继承&#x2F;转换</td><td>Span&lt;T&gt; 可隐式转为 ReadOnlySpan&lt;T&gt;</td><td>ReadOnlySpan&lt;T&gt; 无法转为 Span&lt;T&gt;</td></tr><tr><td>核心适用场景</td><td>只读数据处理（如数据解析、读取）</td><td>可写数据处理（如数据修改、组装）</td></tr><tr><td>核心方法&#x2F;属性</td><td>无写操作相关能力</td><td>包含写操作（如索引赋值、Fill）</td></tr></tbody></table><p>核心定义：<br>Span&lt;T&gt; 是 .NET Core 2.1+&#x2F;.NET 5+ 引入的<strong>可写内存跨度类型</strong>，本质是对连续内存（字符串、数组、非托管内存）的轻量可写视图，同样具备栈分配、零拷贝、低 GC 开销的特性，且支持直接修改指向的内存内容。</p><blockquote><p>注意：与 ReadOnlySpan&lt;T&gt; 一致，Span&lt;T&gt; 同样是栈类型，无法用于异步方法返回值、类字段等跨上下文场景，跨上下文可写场景需改用 Memory&lt;T&gt;。</p></blockquote><h2 id="二、Span-独有的核心能力（ReadOnlySpan-无）"><a href="#二、Span-独有的核心能力（ReadOnlySpan-无）" class="headerlink" title="二、Span&lt;T&gt; 独有的核心能力（ReadOnlySpan&lt;T&gt; 无）"></a>二、Span&lt;T&gt; 独有的核心能力（ReadOnlySpan&lt;T&gt; 无）</h2><p>Span&lt;T&gt; 最核心的价值是<strong>可修改内存内容</strong>，同时扩展了一系列写操作相关的方法&#x2F;属性，以下是其独有的关键能力：</p><h3 id="1-索引器可写：直接修改指定位置的元素"><a href="#1-索引器可写：直接修改指定位置的元素" class="headerlink" title="1. 索引器可写：直接修改指定位置的元素"></a>1. 索引器可写：直接修改指定位置的元素</h3><p>ReadOnlySpan&lt;T&gt; 的索引器仅支持“读”，而 Span&lt;T&gt; 支持通过索引直接修改原内存中的数据：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">// ReadOnlySpan&lt;T&gt; 仅可读</span></span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">int</span>&gt; readOnlySpan = nums.AsSpan();</span><br><span class="line"><span class="comment">// readOnlySpan[0] = 100; // 编译报错：只读索引器无法赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Span&lt;T&gt; 可写</span></span><br><span class="line">Span&lt;<span class="built_in">int</span>&gt; writableSpan = nums.AsSpan();</span><br><span class="line">writableSpan[<span class="number">0</span>] = <span class="number">100</span>; <span class="comment">// 直接修改原数组的第一个元素</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, nums)); <span class="comment">// 输出：100,2,3,4,5</span></span><br></pre></td></tr></table></figure><h3 id="2-专属写操作方法"><a href="#2-专属写操作方法" class="headerlink" title="2. 专属写操作方法"></a>2. 专属写操作方法</h3><p>Span&lt;T&gt; 提供了 ReadOnlySpan&lt;T&gt; 没有的写操作方法，典型如下：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>Fill(T)</td><td>将 Span&lt;T&gt; 的所有元素填充为指定值</td></tr><tr><td>Clear()</td><td>将 Span&lt;T&gt; 的所有元素重置为类型默认值（如 int 重置为 0，string 重置为 null）</td></tr><tr><td>CopyTo(Span&lt;T&gt;)</td><td>（虽 ReadOnlySpan&lt;T&gt; 也有，但 Span&lt;T&gt; 可复制到可写目标后修改）</td></tr></tbody></table><h4 id="案例1：Fill-填充所有元素"><a href="#案例1：Fill-填充所有元素" class="headerlink" title="案例1：Fill 填充所有元素"></a>案例1：Fill 填充所有元素</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 byte 数组</span></span><br><span class="line"><span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">5</span>];</span><br><span class="line">Span&lt;<span class="built_in">byte</span>&gt; bufferSpan = buffer.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充所有元素为 0xFF</span></span><br><span class="line">bufferSpan.Fill(<span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：255,255,255,255,255</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, buffer));</span><br></pre></td></tr></table></figure><h4 id="案例2：Clear-重置元素为默认值"><a href="#案例2：Clear-重置元素为默认值" class="headerlink" title="案例2：Clear 重置元素为默认值"></a>案例2：Clear 重置元素为默认值</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] strs = &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span> &#125;;</span><br><span class="line">Span&lt;<span class="built_in">string</span>&gt; strSpan = strs.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空 Span 内所有元素（重置为 null）</span></span><br><span class="line">strSpan.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：, , , （所有元素为 null）</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, strs));</span><br></pre></td></tr></table></figure><h3 id="3-支持隐式转换为-ReadOnlySpan"><a href="#3-支持隐式转换为-ReadOnlySpan" class="headerlink" title="3. 支持隐式转换为 ReadOnlySpan&lt;T&gt;"></a>3. 支持隐式转换为 ReadOnlySpan&lt;T&gt;</h3><p>Span&lt;T&gt; 可隐式转为 ReadOnlySpan&lt;T&gt;（因可写包含只读能力），反之则不行，这让 Span&lt;T&gt; 适配更多只读场景：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span> &#125;;</span><br><span class="line">Span&lt;<span class="built_in">int</span>&gt; span = arr.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式转换为 ReadOnlySpan&lt;T&gt;</span></span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">int</span>&gt; readOnlySpan = span;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常读取</span></span><br><span class="line">Console.WriteLine(readOnlySpan[<span class="number">1</span>]); <span class="comment">// 输出：20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仍无法修改（ReadOnlySpan&lt;T&gt; 特性）</span></span><br><span class="line"><span class="comment">// readOnlySpan[1] = 200; // 编译报错</span></span><br></pre></td></tr></table></figure><h2 id="三、如何创建-转换-Span？"><a href="#三、如何创建-转换-Span？" class="headerlink" title="三、如何创建&#x2F;转换 Span&lt;T&gt;？"></a>三、如何创建&#x2F;转换 Span&lt;T&gt;？</h2><p>与 ReadOnlySpan&lt;T&gt; 类似，Span&lt;T&gt; 无公共构造函数，需通过 MemoryExtensions.AsSpan 方法转换常见类型，低版本 .NET 同样需安装 System.Memory NuGet 包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 低版本 .NET 安装依赖</span></span><br><span class="line">Install-Package System.Memory</span><br><span class="line"><span class="comment"># 或 .NET CLI</span></span><br><span class="line">dotnet add package System.Memory</span><br></pre></td></tr></table></figure><h3 id="1-数组转-Span（最常用）"><a href="#1-数组转-Span（最常用）" class="headerlink" title="1. 数组转 Span&lt;T&gt;（最常用）"></a>1. 数组转 Span&lt;T&gt;（最常用）</h3><p>任意数组可直接转为 Span&lt;T&gt;，转换后修改 Span&lt;T&gt; 会同步修改原数组：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始数组</span></span><br><span class="line"><span class="built_in">char</span>[] chars = &#123; <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// 转为 Span&lt;char&gt;</span></span><br><span class="line">Span&lt;<span class="built_in">char</span>&gt; charSpan = chars.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 Span 内容（同步修改原数组）</span></span><br><span class="line">charSpan[<span class="number">4</span>] = <span class="string">&#x27;O&#x27;</span>; <span class="comment">// 将最后一个 &#x27;l&#x27; 改为 &#x27;O&#x27;</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;&quot;</span>, chars)); <span class="comment">// 输出：HellO</span></span><br></pre></td></tr></table></figure><h3 id="2-字符串转-Span（特殊注意）"><a href="#2-字符串转-Span（特殊注意）" class="headerlink" title="2. 字符串转 Span（特殊注意）"></a>2. 字符串转 Span<char>（特殊注意）</h3><p>字符串是<strong>不可变类型</strong>，因此字符串转换的 Span<char> 本质仍是只读（底层做了保护），尝试修改会抛出 System.AccessViolationException：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment">// 字符串转 Span&lt;char&gt;（实际是只读封装）</span></span><br><span class="line">Span&lt;<span class="built_in">char</span>&gt; strSpan = str.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码会运行时报错：尝试修改只读内存</span></span><br><span class="line"><span class="comment">// strSpan[0] = &#x27;h&#x27;; </span></span><br></pre></td></tr></table></figure><blockquote><p>若需修改字符串内容，需先将字符串转为 char 数组，再转 Span&lt;T&gt;：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">char</span>[] charArr = str.ToCharArray(); <span class="comment">// 拷贝字符串到数组（仅此处有拷贝）</span></span><br><span class="line">Span&lt;<span class="built_in">char</span>&gt; charSpan = charArr.AsSpan();</span><br><span class="line">charSpan[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;&quot;</span>, charArr)); <span class="comment">// 输出：hello</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="3-List-转-Span"><a href="#3-List-转-Span" class="headerlink" title="3. List&lt;T&gt; 转 Span&lt;T&gt;"></a>3. List&lt;T&gt; 转 Span&lt;T&gt;</h3><p>与 ReadOnlySpan&lt;T&gt; 一致，List&lt;T&gt; 需通过 CollectionsMarshal.AsSpan（.NET 5+）或先转数组再转 Span&lt;T&gt;：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; numList = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="comment">// .NET 5+ 直接转（无拷贝）</span></span><br><span class="line">Span&lt;<span class="built_in">int</span>&gt; listSpan = CollectionsMarshal.AsSpan(numList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 Span 内容（同步修改 List）</span></span><br><span class="line">listSpan[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">Console.WriteLine(numList[<span class="number">1</span>]); <span class="comment">// 输出：200</span></span><br></pre></td></tr></table></figure><h2 id="四、Span-的核心优势（对比-ReadOnlySpan-传统操作）"><a href="#四、Span-的核心优势（对比-ReadOnlySpan-传统操作）" class="headerlink" title="四、Span&lt;T&gt; 的核心优势（对比 ReadOnlySpan&lt;T&gt; + 传统操作）"></a>四、Span&lt;T&gt; 的核心优势（对比 ReadOnlySpan&lt;T&gt; + 传统操作）</h2><h3 id="1-保留零拷贝-栈分配优势，新增可写能力"><a href="#1-保留零拷贝-栈分配优势，新增可写能力" class="headerlink" title="1. 保留零拷贝 + 栈分配优势，新增可写能力"></a>1. 保留零拷贝 + 栈分配优势，新增可写能力</h3><p>Span&lt;T&gt; 继承了 ReadOnlySpan&lt;T&gt; 零拷贝、栈分配无 GC 开销的特性，同时解决了 ReadOnlySpan&lt;T&gt; 无法修改数据的痛点，无需为修改数据额外创建拷贝：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式：修改数组片段需拷贝</span></span><br><span class="line"><span class="built_in">int</span>[] source = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] subCopy = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>];</span><br><span class="line">Array.Copy(source, <span class="number">1</span>, subCopy, <span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 拷贝数据</span></span><br><span class="line">subCopy[<span class="number">0</span>] = <span class="number">200</span>; <span class="comment">// 修改拷贝后的数组，原数组无变化</span></span><br><span class="line">Console.WriteLine(source[<span class="number">1</span>]); <span class="comment">// 输出：2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Span&lt;T&gt; 方式：零拷贝修改原数组片段</span></span><br><span class="line">Span&lt;<span class="built_in">int</span>&gt; sourceSpan = source.AsSpan();</span><br><span class="line">Span&lt;<span class="built_in">int</span>&gt; subSpan = sourceSpan.Slice(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 零拷贝截取</span></span><br><span class="line">subSpan[<span class="number">0</span>] = <span class="number">200</span>; <span class="comment">// 直接修改原数组</span></span><br><span class="line">Console.WriteLine(source[<span class="number">1</span>]); <span class="comment">// 输出：200</span></span><br></pre></td></tr></table></figure><h3 id="2-高性能修改连续内存，避免临时对象"><a href="#2-高性能修改连续内存，避免临时对象" class="headerlink" title="2. 高性能修改连续内存，避免临时对象"></a>2. 高性能修改连续内存，避免临时对象</h3><p>传统修改数组&#x2F;字符串的方式易产生大量临时对象（如 string.Substring、Array.Copy），而 Span&lt;T&gt; 直接操作原内存，无额外内存分配：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：批量修改字节数组前10个元素为 0x01</span></span><br><span class="line"><span class="built_in">byte</span>[] data = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方式：循环赋值（无拷贝，但语法繁琐）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    data[i] = <span class="number">0x01</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Span&lt;T&gt; 方式：Slice + Fill 简洁高效</span></span><br><span class="line">data.AsSpan(<span class="number">0</span>, <span class="number">10</span>).Fill(<span class="number">0x01</span>); <span class="comment">// 截取前10个元素并填充，零拷贝</span></span><br></pre></td></tr></table></figure><h3 id="3-内存安全：越界操作直接抛异常，避免内存越访问"><a href="#3-内存安全：越界操作直接抛异常，避免内存越访问" class="headerlink" title="3. 内存安全：越界操作直接抛异常，避免内存越访问"></a>3. 内存安全：越界操作直接抛异常，避免内存越访问</h3><p>Span&lt;T&gt; 会校验索引&#x2F;长度的合法性，越界操作（如 Slice 超出范围、索引访问越界）会立即抛出 ArgumentOutOfRangeException，相比直接操作指针更安全：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">Span&lt;<span class="built_in">int</span>&gt; span = nums.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 越界访问索引，直接抛异常</span></span><br><span class="line"><span class="comment">// Console.WriteLine(span[3]); // 报错：索引超出范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 越界 Slice，直接抛异常</span></span><br><span class="line"><span class="comment">// span.Slice(1, 3); // 报错：长度超出范围</span></span><br></pre></td></tr></table></figure><h2 id="五、Span-核心方法实战（对比-ReadOnlySpan-补充）"><a href="#五、Span-核心方法实战（对比-ReadOnlySpan-补充）" class="headerlink" title="五、Span&lt;T&gt; 核心方法实战（对比 ReadOnlySpan&lt;T&gt; 补充）"></a>五、Span&lt;T&gt; 核心方法实战（对比 ReadOnlySpan&lt;T&gt; 补充）</h2><p>除了 ReadOnlySpan&lt;T&gt; 也有的 CopyTo&#x2F;TryCopyTo&#x2F;Slice 方法，以下聚焦 Span&lt;T&gt; 独有的写操作方法案例：</p><h3 id="1-Fill：批量填充元素"><a href="#1-Fill：批量填充元素" class="headerlink" title="1. Fill：批量填充元素"></a>1. Fill：批量填充元素</h3><p>适用于初始化缓冲区、重置数据等场景，比循环赋值更简洁高效：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：初始化 1024 字节的缓冲区为 0</span></span><br><span class="line"><span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line">Span&lt;<span class="built_in">byte</span>&gt; bufferSpan = buffer.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量填充</span></span><br><span class="line">bufferSpan.Fill(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证：前10个元素均为 0</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, bufferSpan.Slice(<span class="number">0</span>, <span class="number">10</span>))); <span class="comment">// 输出：0,0,0,0,0,0,0,0,0,0</span></span><br></pre></td></tr></table></figure><h3 id="2-索引器写操作：精准修改单个元素"><a href="#2-索引器写操作：精准修改单个元素" class="headerlink" title="2. 索引器写操作：精准修改单个元素"></a>2. 索引器写操作：精准修改单个元素</h3><p>适用于按需修改内存中指定位置的数据，无拷贝开销：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：修改数组中指定位置的数值</span></span><br><span class="line"><span class="built_in">int</span>[] scores = &#123; <span class="number">80</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span> &#125;;</span><br><span class="line">Span&lt;<span class="built_in">int</span>&gt; scoreSpan = scores.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改第二个分数为 99</span></span><br><span class="line">scoreSpan[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：80,99,90,95</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, scores));</span><br></pre></td></tr></table></figure><h3 id="3-Clear：快速重置内存内容"><a href="#3-Clear：快速重置内存内容" class="headerlink" title="3. Clear：快速重置内存内容"></a>3. Clear：快速重置内存内容</h3><p>适用于数据脱敏、内存回收前的重置操作，比循环赋值默认值更高效：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：重置敏感数据（如密码数组）</span></span><br><span class="line"><span class="built_in">char</span>[] password = &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span> &#125;;</span><br><span class="line">Span&lt;<span class="built_in">char</span>&gt; pwdSpan = password.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空密码（重置为 &#x27;\0&#x27;）</span></span><br><span class="line">pwdSpan.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：,,,,（所有元素为默认值）</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;&quot;</span>, password));</span><br></pre></td></tr></table></figure><h2 id="六、Span-适用场景-注意事项"><a href="#六、Span-适用场景-注意事项" class="headerlink" title="六、Span&lt;T&gt; 适用场景 &amp; 注意事项"></a>六、Span&lt;T&gt; 适用场景 &amp; 注意事项</h2><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li><strong>高频数据修改</strong>：如网络缓冲区读写、文件流数据处理、二进制数据解析&#x2F;组装；</li><li><strong>内存敏感场景</strong>：如低延迟服务、嵌入式开发，避免 GC 开销和临时对象；</li><li><strong>数组片段修改</strong>：无需拷贝数组，直接修改指定范围的元素。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>栈类型限制：无法用于异步方法返回值、类字段、闭包等场景，跨上下文需改用 Memory&lt;T&gt;；</li><li>字符串不可变：直接转换字符串得到的 Span<char> 不可写，修改需先转 char 数组；</li><li>生命周期：Span&lt;T&gt; 引用的内存需保证在 Span&lt;T&gt; 生命周期内有效（如避免引用已释放的非托管内存、已回收的数组）。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Span&lt;T&gt; 是 ReadOnlySpan&lt;T&gt; 的可写版本，核心差异是支持修改内存内容，且可隐式转为 ReadOnlySpan&lt;T&gt;；</li><li>独有能力：可写索引器、Fill&#x2F;Clear 等写操作方法，零拷贝修改原内存；</li><li>核心优势：保留栈分配、零拷贝、低 GC 开销的同时，解锁高效可写内存操作；</li><li>适用场景：高频数据修改、内存敏感场景、数组片段操作。</li></ol><p>Span&lt;T&gt; 与 ReadOnlySpan&lt;T&gt; 配合，覆盖了 C# 中“只读”和“可写”的高性能内存操作场景，是构建高性能 .NET 应用的核心工具。</p><h2 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h2><p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.span-1?view=net-8.0">Span&lt;T&gt; 结构 - Microsoft Learn</a><br><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.memory-1?view=net-8.0">Memory&lt;T&gt; 结构 - Microsoft Learn</a><br><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.collectionsmarshal?view=net-9.0">CollectionsMarshal 类 - Microsoft Learn</a><br><a href="https://www.nuget.org/packages/System.Memory">System.Memory - NuGet Gallery</a></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Span&lt;T&gt; </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReadOnlySpan&lt;T&gt;：轻量高效的只读内存操作</title>
      <link href="/2026/01/18/readonlyspan-usage/"/>
      <url>/2026/01/18/readonlyspan-usage/</url>
      
        <content type="html"><![CDATA[<h3 id="最后更新时间：2026-01-18-14-29-29"><a href="#最后更新时间：2026-01-18-14-29-29" class="headerlink" title="最后更新时间：2026-01-18 14:29:29"></a><strong>最后更新时间：2026-01-18 14:29:29</strong></h3><p>本文通过豆包辅助生成！</p><hr><!--帮我写一篇 markdown 文章，是关于 C# 的 ReadOnlySpan<T> 简单介绍+简单的使用教程+案例 的内容，需要把以下所有要求罗列出来：1. 介绍 ReadOnlySpan<T> 是什么；2. 在 string、数组、List<T>（其他列表不知道行不行）中，通过 MemoryExtensions.AsSpan 转化为 ReadOnlySpan<T> （如果当前 .net 版本不存在 MemoryExtensions 时，通过 NuGet 安装 System.Memory 库）；3. 为什么使用 ReadOnlySpan<T>？有什么优势？  1. ReadOnlySpan<T> 的优势；  2. 相比直接操作 string 的方法，通过 MemoryExtensions.AsSpan 转换为 ReadOnlySpan<char> 时，那些方法的执行效率提高（高版本的 string 的方法内部实现也使用了 ReadOnlySpan，只有低版本没优化）；  3. 也介绍 数组、列表 等其他。4. ReadOnlySpan<T> 属性教程+案例（案例用 string），只介绍：  - Item[Int32]：从指定从零开始的索引处的只读范围获取项。  - Length：只读范围中的项数。5. ReadOnlySpan<T> 方法教程+案例（案例用 数组），只介绍：  - CopyTo(Span<T>)：将此 ReadOnlySpan<T> 的内容复制到目标 Span<T>。  - TryCopyTo(Span<T>)：尝试将此 ReadOnlySpan<T> 的内容复制到 Span<T> 中，并返回一个值以指示操作是否成功。  - Slice(Int32)：形成从当前只读范围开始的切片，该范围从指定的索引处开始。  - Slice(Int32, Int32)：形成从指定长度的指定索引处开始的当前只读范围的切片。  - 还有其他像 Contains、StartsWith、EndsWith、IndexOf 等，通过文档 / 网络教程查看。--><p>在 C# 中，ReadOnlySpan&lt;T&gt; 是处理内存片段的核心类型，尤其适合高频读写、低内存开销的场景。本文将从“是什么、怎么用、为什么好用”三个维度，带你快速掌握 ReadOnlySpan&lt;T&gt; 的基础用法和核心优势。</p><h2 id="一、ReadOnlySpan-是什么？"><a href="#一、ReadOnlySpan-是什么？" class="headerlink" title="一、ReadOnlySpan&lt;T&gt; 是什么？"></a>一、ReadOnlySpan&lt;T&gt; 是什么？</h2><p>ReadOnlySpan&lt;T&gt; 是 .NET Core 2.1+&#x2F;.NET 5+ 引入的<strong>只读内存跨度类型</strong>，本质是对一段连续内存（如字符串、数组、非托管内存）的“轻量视图”——它不分配新内存，仅记录内存的起始地址和长度，且<strong>无法修改指向的内存内容</strong>，因此兼具高性能和内存安全。</p><p>核心特点：</p><ul><li><strong>栈分配（stack-only）</strong>：实例存储在栈上，无 GC 开销；</li><li>只读特性：仅能读取内存内容，无法修改，避免意外数据篡改；</li><li>零拷贝：操作内存时不复制数据，直接引用原内存区域。</li></ul><blockquote><p>注意：ReadOnlySpan&lt;T&gt; 不能用于异步方法的返回值、类的字段等场景（栈类型限制），若需跨上下文使用，可改用 ReadOnlyMemory&lt;T&gt;。</p></blockquote><h2 id="二、如何将常见类型转为-ReadOnlySpan？"><a href="#二、如何将常见类型转为-ReadOnlySpan？" class="headerlink" title="二、如何将常见类型转为 ReadOnlySpan&lt;T&gt;？"></a>二、如何将常见类型转为 ReadOnlySpan&lt;T&gt;？</h2><p>ReadOnlySpan&lt;T&gt; 无法直接创建（无公共构造函数），需通过 MemoryExtensions.AsSpan 方法将字符串、数组、列表等转为 ReadOnlySpan&lt;T&gt;。</p><h3 id="前置条件：安装依赖（低版本-NET-需处理）"><a href="#前置条件：安装依赖（低版本-NET-需处理）" class="headerlink" title="前置条件：安装依赖（低版本 .NET 需处理）"></a>前置条件：安装依赖（低版本 .NET 需处理）</h3><p>若你的 .NET 版本（如 .NET Framework 4.x）未内置 MemoryExtensions，需先安装 NuGet 包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Install-Package System.Memory</span><br><span class="line"><span class="comment"># 或 .NET CLI</span></span><br><span class="line">dotnet add package System.Memory</span><br></pre></td></tr></table></figure><h3 id="1-字符串转-ReadOnlySpan"><a href="#1-字符串转-ReadOnlySpan" class="headerlink" title="1. 字符串转 ReadOnlySpan&lt;char&gt;"></a>1. 字符串转 ReadOnlySpan&lt;char&gt;</h3><p>字符串本质是 char 数组，转换后可直接操作字符片段，且无字符串拷贝开销：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始字符串</span></span><br><span class="line"><span class="built_in">string</span> originalStr = <span class="string">&quot;Hello ReadOnlySpan!&quot;</span>;</span><br><span class="line"><span class="comment">// 转为 ReadOnlySpan&lt;char&gt;</span></span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">char</span>&gt; strSpan = originalStr.AsSpan(); <span class="comment">// 等价于 MemoryExtensions.AsSpan(originalStr)</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(strSpan); <span class="comment">// 输出：Hello ReadOnlySpan!</span></span><br></pre></td></tr></table></figure><h3 id="2-数组转-ReadOnlySpan"><a href="#2-数组转-ReadOnlySpan" class="headerlink" title="2. 数组转 ReadOnlySpan&lt;T&gt;"></a>2. 数组转 ReadOnlySpan&lt;T&gt;</h3><p>任意数组（如 int[]、byte[]）均可直接转换，适配任意值类型&#x2F;引用类型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始 int 数组</span></span><br><span class="line"><span class="built_in">int</span>[] numArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">// 转为 ReadOnlySpan&lt;int&gt;</span></span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">int</span>&gt; arraySpan = numArray.AsSpan();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(arraySpan.Length); <span class="comment">// 输出：5</span></span><br></pre></td></tr></table></figure><h3 id="3-List-转-ReadOnlySpan"><a href="#3-List-转-ReadOnlySpan" class="headerlink" title="3. List&lt;T&gt; 转 ReadOnlySpan&lt;T&gt;"></a>3. List&lt;T&gt; 转 ReadOnlySpan&lt;T&gt;</h3><p>若要将 List&lt;T&gt; 转为 ReadOnlySpan&lt;T&gt;，有两种方法可以实现：</p><ol><li>先将 List&lt;T&gt; 通过 ToArray() 转为数组（因 List 内存非绝对连续），再转 ReadOnlySpan&lt;T&gt;：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始 List&lt;string&gt;</span></span><br><span class="line">List&lt;<span class="built_in">string</span>&gt; strList = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// List → 数组 → ReadOnlySpan&lt;T&gt;</span></span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">string</span>&gt; listSpan = strList.ToArray().AsSpan();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(listSpan[<span class="number">1</span>]); <span class="comment">// 输出：b</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过 CollectionsMarshal.AsSpan&lt;T&gt;(List&lt;T&gt;) 转为 ReadOnlySpan&lt;T&gt;：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始 List&lt;string&gt;</span></span><br><span class="line">List&lt;<span class="built_in">string</span>&gt; strList = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// List → 数组 → ReadOnlySpan&lt;T&gt;</span></span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">string</span>&gt; listSpan = CollectionsMarshal.AsSpan(strList);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(listSpan[<span class="number">1</span>]); <span class="comment">// 输出：b</span></span><br></pre></td></tr></table></figure><blockquote><p>CollectionsMarshal 类需要 .NET 5+ 才能使用，或者通过 NuGet 安装包 System.Runtime.InteropServices（未测试过，不确定存不存在 CollectionsMarshal 类）。</p></blockquote><h2 id="三、为什么要使用-ReadOnlySpan？核心优势"><a href="#三、为什么要使用-ReadOnlySpan？核心优势" class="headerlink" title="三、为什么要使用 ReadOnlySpan&lt;T&gt;？核心优势"></a>三、为什么要使用 ReadOnlySpan&lt;T&gt;？核心优势</h2><p>相比直接操作字符串、数组，ReadOnlySpan&lt;T&gt; 最大的价值是<strong>零拷贝 + 低 GC 开销</strong>，具体优势如下：</p><h3 id="1-核心优势总结"><a href="#1-核心优势总结" class="headerlink" title="1. 核心优势总结"></a>1. 核心优势总结</h3><table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td>零内存拷贝</td><td>操作内存片段时（如截取子串、取数组片段），仅修改“视图范围”，不复制原数据</td></tr><tr><td>无 GC 压力</td><td>栈分配类型，实例无需 GC 回收；避免频繁创建临时字符串&#x2F;数组导致的 GC 触发</td></tr><tr><td>内存安全</td><td>只读特性防止意外修改原数据，索引越界会直接抛出异常，避免内存越访问</td></tr><tr><td>高性能</td><td>直接操作内存地址，比传统字符串&#x2F;数组方法（如 string.Substring）快数倍</td></tr></tbody></table><h3 id="2-对比-string：效率大幅提升"><a href="#2-对比-string：效率大幅提升" class="headerlink" title="2. 对比 string：效率大幅提升"></a>2. 对比 string：效率大幅提升</h3><p>传统 string 是不可变类型，调用 Substring、Split 等方法时，会创建<strong>新字符串实例</strong>（拷贝原字符数据），高频操作时会产生大量临时对象，触发频繁 GC。</p><p>而 ReadOnlySpan&lt;char&gt; 操作字符串时无拷贝：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式：创建新字符串（拷贝数据）</span></span><br><span class="line"><span class="built_in">string</span> original = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> subStr = original.Substring(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 生成新字符串 &quot;Hello&quot;，拷贝5个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadOnlySpan 方式：零拷贝，仅调整视图范围</span></span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">char</span>&gt; span = original.AsSpan();</span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">char</span>&gt; subSpan = span.Slice(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 无拷贝，仅指向原字符串的前5个字符</span></span><br></pre></td></tr></table></figure><blockquote><p>补充：高版本 .NET 的 string 内置方法（如 Substring）已底层适配 ReadOnlySpan&lt;char&gt;，但低版本 .NET 仍为拷贝实现——因此低版本中手动用 ReadOnlySpan&lt;char&gt; 优化效果更显著。</p></blockquote><h3 id="3-对比数组-列表：更轻量的内存操作"><a href="#3-对比数组-列表：更轻量的内存操作" class="headerlink" title="3. 对比数组&#x2F;列表：更轻量的内存操作"></a>3. 对比数组&#x2F;列表：更轻量的内存操作</h3><p>直接操作数组时，截取片段（如 Array.Copy）需拷贝数据；而 ReadOnlySpan&lt;T&gt; 仅通过 Slice 方法调整视图，无拷贝开销：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方式：拷贝数组片段（创建新数组）</span></span><br><span class="line"><span class="built_in">int</span>[] subNums = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>];</span><br><span class="line">Array.Copy(nums, <span class="number">1</span>, subNums, <span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 拷贝索引1-3的元素，生成新数组 [2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadOnlySpan 方式：零拷贝，仅定义视图</span></span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">int</span>&gt; subSpan = nums.AsSpan().Slice(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 直接指向原数组的索引1-3，无拷贝</span></span><br></pre></td></tr></table></figure><h2 id="四、ReadOnlySpan-核心属性（案例：string）"><a href="#四、ReadOnlySpan-核心属性（案例：string）" class="headerlink" title="四、ReadOnlySpan&lt;T&gt; 核心属性（案例：string）"></a>四、ReadOnlySpan&lt;T&gt; 核心属性（案例：string）</h2><p>仅介绍高频使用的 2 个核心属性，案例基于字符串场景：</p><h3 id="1-Item-Int32-：获取指定索引的元素"><a href="#1-Item-Int32-：获取指定索引的元素" class="headerlink" title="1. Item[Int32]：获取指定索引的元素"></a>1. Item[Int32]：获取指定索引的元素</h3><p>通过索引访问 ReadOnlySpan&lt;T&gt; 中的元素，语法与数组一致，<strong>只读不可改</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> text = <span class="string">&quot;C# ReadOnlySpan Tutorial&quot;</span>;</span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">char</span>&gt; textSpan = text.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取索引2的字符（索引从0开始）</span></span><br><span class="line"><span class="built_in">char</span> charAt2 = textSpan[<span class="number">2</span>]; </span><br><span class="line">Console.WriteLine(charAt2); <span class="comment">// 输出：空格（&quot;C# &quot; 的第三个字符）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改会编译报错：ReadOnlySpan 只读</span></span><br><span class="line"><span class="comment">// textSpan[2] = &#x27;x&#x27;; // 错误：无法给只读索引器赋值</span></span><br></pre></td></tr></table></figure><h3 id="2-Length：获取只读范围的元素数量"><a href="#2-Length：获取只读范围的元素数量" class="headerlink" title="2. Length：获取只读范围的元素数量"></a>2. Length：获取只读范围的元素数量</h3><p>返回 ReadOnlySpan&lt;T&gt; 包含的元素总数，等价于原数据的有效长度：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> text = <span class="string">&quot;Hello ReadOnlySpan&quot;</span>;</span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">char</span>&gt; textSpan = text.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取长度</span></span><br><span class="line"><span class="built_in">int</span> length = textSpan.Length;</span><br><span class="line">Console.WriteLine(length); <span class="comment">// 输出：17（&quot;Hello ReadOnlySpan&quot; 共17个字符）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空 Span 的 Length 为 0</span></span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">char</span>&gt; emptySpan = ReadOnlySpan&lt;<span class="built_in">char</span>&gt;.Empty;</span><br><span class="line">Console.WriteLine(emptySpan.Length); <span class="comment">// 输出：0</span></span><br></pre></td></tr></table></figure><h2 id="五、ReadOnlySpan-核心方法（案例：数组）"><a href="#五、ReadOnlySpan-核心方法（案例：数组）" class="headerlink" title="五、ReadOnlySpan&lt;T&gt; 核心方法（案例：数组）"></a>五、ReadOnlySpan&lt;T&gt; 核心方法（案例：数组）</h2><p>以下方法均基于 int[] 数组案例，聚焦高频使用的 4 个方法：</p><h3 id="1-CopyTo-Span-：复制内容到目标-Span"><a href="#1-CopyTo-Span-：复制内容到目标-Span" class="headerlink" title="1. CopyTo(Span&lt;T&gt;)：复制内容到目标 Span&lt;T&gt;"></a>1. CopyTo(Span&lt;T&gt;)：复制内容到目标 Span&lt;T&gt;</h3><p>将 ReadOnlySpan&lt;T&gt; 的内容复制到可写的 Span&lt;T&gt;（需保证目标 Span 长度足够，否则抛异常）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源数组 → ReadOnlySpan&lt;int&gt;</span></span><br><span class="line"><span class="built_in">int</span>[] source = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">int</span>&gt; sourceSpan = source.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标 Span（长度需 ≥ 源 Span）</span></span><br><span class="line"><span class="built_in">int</span>[] target = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>];</span><br><span class="line">Span&lt;<span class="built_in">int</span>&gt; targetSpan = target.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制内容</span></span><br><span class="line">sourceSpan.CopyTo(targetSpan);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出目标数组：[10,20,30,40]</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, target)); </span><br></pre></td></tr></table></figure><h3 id="2-TryCopyTo-Span-：安全复制（返回操作结果）"><a href="#2-TryCopyTo-Span-：安全复制（返回操作结果）" class="headerlink" title="2. TryCopyTo(Span&lt;T&gt;)：安全复制（返回操作结果）"></a>2. TryCopyTo(Span&lt;T&gt;)：安全复制（返回操作结果）</h3><p>与 CopyTo 功能一致，但不会抛异常——若目标 Span 长度不足，返回 false，否则返回 true：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] source = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">int</span>&gt; sourceSpan = source.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标 Span 长度不足（仅3个元素）</span></span><br><span class="line"><span class="built_in">int</span>[] target = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>];</span><br><span class="line">Span&lt;<span class="built_in">int</span>&gt; targetSpan = target.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试复制</span></span><br><span class="line"><span class="built_in">bool</span> isSuccess = sourceSpan.TryCopyTo(targetSpan);</span><br><span class="line">Console.WriteLine(isSuccess); <span class="comment">// 输出：False（长度不足，复制失败）</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, target)); <span class="comment">// 输出：0,0,0（无数据复制）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整目标长度后重试</span></span><br><span class="line"><span class="built_in">int</span>[] target2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">bool</span> isSuccess2 = sourceSpan.TryCopyTo(target2.AsSpan());</span><br><span class="line">Console.WriteLine(isSuccess2); <span class="comment">// 输出：True</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, target2)); <span class="comment">// 输出：10,20,30,40</span></span><br></pre></td></tr></table></figure><h3 id="3-Slice-Int32-：从指定索引开始截取片段"><a href="#3-Slice-Int32-：从指定索引开始截取片段" class="headerlink" title="3. Slice(Int32)：从指定索引开始截取片段"></a>3. Slice(Int32)：从指定索引开始截取片段</h3><p>截取从 startIndex 到末尾的所有元素，零拷贝仅调整视图：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">int</span>&gt; numSpan = nums.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引2开始截取（包含索引2）</span></span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">int</span>&gt; sliceSpan = numSpan.Slice(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：3,4,5（索引2、3、4的元素）</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, sliceSpan)); </span><br></pre></td></tr></table></figure><h3 id="4-Slice-Int32-Int32-：指定索引-长度截取片段"><a href="#4-Slice-Int32-Int32-：指定索引-长度截取片段" class="headerlink" title="4. Slice(Int32, Int32)：指定索引+长度截取片段"></a>4. Slice(Int32, Int32)：指定索引+长度截取片段</h3><p>截取从 startIndex 开始、长度为 length 的片段，需保证 startIndex + length ≤ 原 Span 长度：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">int</span>&gt; numSpan = nums.AsSpan();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引1开始，截取3个元素</span></span><br><span class="line">ReadOnlySpan&lt;<span class="built_in">int</span>&gt; sliceSpan = numSpan.Slice(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：2,3,4（索引1、2、3的元素）</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, sliceSpan)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引越界会抛异常</span></span><br><span class="line"><span class="comment">// numSpan.Slice(1, 5); // 错误：长度超出范围</span></span><br></pre></td></tr></table></figure><h3 id="补充：其他常用方法"><a href="#补充：其他常用方法" class="headerlink" title="补充：其他常用方法"></a>补充：其他常用方法</h3><p>ReadOnlySpan&lt;T&gt; 还内置了大量实用方法，可参考官方文档&#x2F;网络教程：</p><ul><li>Contains(T)：判断是否包含指定元素；</li><li>StartsWith(ReadOnlySpan&lt;T&gt;)：判断是否以指定片段开头；</li><li>EndsWith(ReadOnlySpan&lt;T&gt;)：判断是否以指定片段结尾；</li><li>IndexOf(T)：查找指定元素的第一个索引；</li><li>LastIndexOf(T)：查找指定元素的最后一个索引。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>ReadOnlySpan&lt;T&gt; 是只读的内存视图，通过 AsSpan() 从字符串&#x2F;数组&#x2F;列表转换，低版本需安装 System.Memory；</li><li>核心优势是零拷贝、低 GC 开销，相比传统字符串&#x2F;数组操作效率大幅提升；</li><li>核心属性：Item[Int32]（索引访问）、Length（获取长度）；</li><li>核心方法：CopyTo&#x2F;TryCopyTo（复制）、Slice（截取片段），适配高性能内存操作场景。</li></ol><p>ReadOnlySpan&lt;T&gt; 尤其适合高频处理字符串、字节数组的场景（如网络IO、数据解析），是 C# 高性能编程的必备工具。</p><h2 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h2><p><a href="https://www.nuget.org/packages/System.Memory">System.Memory - NuGet Gallery</a><br><a href="https://www.nuget.org/packages/System.Runtime.InteropServices">System.Runtime.InteropServices - NuGet Gallery</a><br><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.memoryextensions?view=net-8.0">ReadOnlySpan&lt;T&gt; 结构 - Microsoft Learn</a><br><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.memoryextensions?view=net-8.0">MemoryExtensions 类 - Microsoft Learn</a><br><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.collectionsmarshal?view=net-9.0">CollectionsMarshal 类 - Microsoft Learn</a></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> ReadOnlySpan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 ArrayPool 的你应该了解的内容</title>
      <link href="/2026/01/17/arraypool-what-you-should-know/"/>
      <url>/2026/01/17/arraypool-what-you-should-know/</url>
      
        <content type="html"><![CDATA[<h3 id="最后更新时间：2026-01-17-15-30-37"><a href="#最后更新时间：2026-01-17-15-30-37" class="headerlink" title="最后更新时间：2026-01-17 15:30:37"></a><strong>最后更新时间：2026-01-17 15:30:37</strong></h3><hr><h2 id="ArrayPool-Rent-方法：是否需要-try-catch？源码视角的终极解答"><a href="#ArrayPool-Rent-方法：是否需要-try-catch？源码视角的终极解答" class="headerlink" title="ArrayPool&lt;T&gt;.Rent 方法：是否需要 try-catch？源码视角的终极解答"></a>ArrayPool&lt;T&gt;.Rent 方法：是否需要 try-catch？源码视角的终极解答</h2><p>在使用 ArrayPool&lt;T&gt;.Shared.Rent(int minimumLength) 时，很多开发者会纠结“是否需要用 try-catch 包裹”。以下结合 ArrayPool 源码，从“风险场景、报错条件、特殊情况”三方面，明确最佳实践和代码写法。</p><h3 id="一、无源码认知时的安全写法"><a href="#一、无源码认知时的安全写法" class="headerlink" title="一、无源码认知时的安全写法"></a>一、无源码认知时的安全写法</h3><p>如果不了解 Rent 方法的底层逻辑，最稳妥的代码实现如下（核心是“确保数组最终归还”）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[]? buffer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 尝试从对象池租借数组</span></span><br><span class="line">    buffer = ArrayPool&lt;<span class="built_in">byte</span>&gt;.Shared.Rent(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑：使用数组处理数据</span></span><br><span class="line">    buffer[<span class="number">0</span>] = <span class="number">123</span>;</span><br><span class="line">    buffer[<span class="number">1</span>] = <span class="number">234</span>;</span><br><span class="line">    buffer[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// ... 其他数据处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 关键：无论是否报错，都必须归还数组（避免池资源泄漏）</span></span><br><span class="line">    <span class="keyword">if</span> (buffer != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ArrayPool&lt;<span class="built_in">byte</span>&gt;.Shared.Return(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心目的：不确定 Rent 是否会抛异常、业务逻辑是否会出错，用 try-finally 保证数组“租借-归还”的闭环，避免对象池资源耗尽。</p><h3 id="二、源码视角：Rent-方法的核心逻辑（决定是否需要-try-catch）"><a href="#二、源码视角：Rent-方法的核心逻辑（决定是否需要-try-catch）" class="headerlink" title="二、源码视角：Rent 方法的核心逻辑（决定是否需要 try-catch）"></a>二、源码视角：Rent 方法的核心逻辑（决定是否需要 try-catch）</h3><p>通过分析 ArrayPool 源码，可明确 Rent 的报错场景、资源耗尽处理、特殊参数处理，进而判断 try-catch 的必要性。</p><ol><li><strong>对象池“无可用数组”时：不会报错，自动新建数组</strong></li></ol><p>很多人担心“频繁 Rent 不 Return，导致池为空时会报错”——但源码已处理此场景，不会抛异常：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码核心逻辑：池无可用数组时的降级处理</span></span><br><span class="line">T[]? buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 尝试从对象池的对应桶中获取数组（省略池查找逻辑）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 降级：直接新建数组（区分基元类型优化）</span></span><br><span class="line">buffer = <span class="keyword">typeof</span>(T).IsPrimitive &amp;&amp; <span class="keyword">typeof</span>(T) != <span class="keyword">typeof</span>(<span class="built_in">bool</span>) </span><br><span class="line">    ? GC.AllocateUninitializedArray&lt;T&gt;(minimumLength)  <span class="comment">// 基元类型（除bool）：无零初始化，性能更优</span></span><br><span class="line">    : <span class="keyword">new</span> T[minimumLength];  <span class="comment">// 其他类型：常规零初始化</span></span><br></pre></td></tr></table></figure><p>结论：对象池耗尽时，Rent 会自动新建数组返回，不会抛异常。</p><p><strong>关键说明</strong>：</p><ul><li>Type.IsPrimitive：判断类型是否为 .NET <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.type.isprimitive?view=net-9.0">基元类型</a>；</li><li>GC.AllocateUninitializedArray&lt;T&gt;：功能等价于 new T[length]，但对基元类型跳过“零初始化”（避免额外性能开销）。</li></ul><ol start="2"><li><strong>Rent 仅有的报错场景：minimumLength &lt; 0</strong></li></ol><p>源码明确限制“请求长度不能为负数”，否则直接抛异常：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码校验逻辑：负数长度直接报错</span></span><br><span class="line">ArgumentOutOfRangeException.ThrowIfNegative(minimumLength);</span><br></pre></td></tr></table></figure><p><strong>关键说明</strong>：</p><ul><li>只有当 minimumLength &lt; 0 时，Rent 才会抛出 ArgumentOutOfRangeException；</li><li>无需用 try-catch 捕获此异常：调用前直接判断参数即可（异常捕获会增加性能损耗）。</li></ul><ol start="3"><li><strong>特殊情况：minimumLength &#x3D; 0 时的处理</strong></li></ol><p>当传入 minimumLength &#x3D; 0（合法参数），源码会返回空数组单例，不会新建或从池获取：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码逻辑：处理 0 长度请求</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (minimumLength == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 允许 0 长度请求（虽无池复用价值，但保证 API 通用性）</span></span><br><span class="line">    <span class="comment">// 不会分配内存，直接返回空数组单例，归还时也不会存入池</span></span><br><span class="line">    <span class="keyword">return</span> Array.Empty&lt;T&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键说明</strong>：</p><ul><li>返回值是 Array.Empty&lt;T&gt;()（空数组单例），长度为 0；</li><li>使用时需先判断数组长度：if (buffer.Length &#x3D;&#x3D; 0)，避免索引越界。</li></ul><h2 id="三、最终结论：是否需要-try-catch？"><a href="#三、最终结论：是否需要-try-catch？" class="headerlink" title="三、最终结论：是否需要 try-catch？"></a>三、最终结论：是否需要 try-catch？</h2><ol><li><strong>针对 Rent 方法本身：不需要 try-catch</strong></li></ol><ul><li>Rent 仅在 minimumLength &lt; 0 时抛异常，可提前判断参数避免；</li><li>池资源耗尽时会自动新建数组，无其他报错场景。</li></ul><ol start="2"><li><strong>针对业务逻辑：建议用 try-finally（无需 catch）</strong></li></ol><ul><li>核心目的不是捕获 Rent 的异常，而是<strong>确保数组必须归还</strong>（即使业务逻辑报错，也不会导致池资源泄漏）；</li><li>优化后的最终写法（无多余 catch，仅用 try-finally 保证归还）：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[]? buffer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 提前校验参数：避免 Rent 抛出负数异常</span></span><br><span class="line">    <span class="keyword">if</span> (minimumLength &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="keyword">nameof</span>(minimumLength), <span class="string">&quot;数组长度不能为负数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer = ArrayPool&lt;<span class="built_in">byte</span>&gt;.Shared.Rent(minimumLength);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 业务逻辑（可能报错，如索引越界、数据处理异常）</span></span><br><span class="line">    <span class="keyword">if</span> (buffer.Length &gt; <span class="number">0</span>) <span class="comment">// 处理 minimumLength=0 返回空数组的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        buffer[<span class="number">0</span>] = <span class="number">123</span>;</span><br><span class="line">        <span class="comment">// ... 其他逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 无论业务是否报错，强制归还数组</span></span><br><span class="line">    <span class="keyword">if</span> (buffer != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ArrayPool&lt;<span class="built_in">byte</span>&gt;.Shared.Return(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、关键补充：归还数组的注意事项"><a href="#四、关键补充：归还数组的注意事项" class="headerlink" title="四、关键补充：归还数组的注意事项"></a>四、关键补充：归还数组的注意事项</h2><ol><li>即使 minimumLength&#x3D;0 返回空数组，Return 也不会报错（源码会忽略空数组的归还，不会存入池）；</li><li>数组归还后不可再使用：Return 后数组可能被池复用，再次操作会导致数据篡改；</li><li>基元类型的性能优化：GC.AllocateUninitializedArray&lt;T&gt; 无零初始化，比 new T[length] 更快，无需手动优化。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Array </tag>
            
            <tag> ArrayPool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尽量使用 ArrayPool 类</title>
      <link href="/2026/01/16/perfer-arraypool-usage/"/>
      <url>/2026/01/16/perfer-arraypool-usage/</url>
      
        <content type="html"><![CDATA[<h3 id="最后更新时间：2026-01-17-14-39-55"><a href="#最后更新时间：2026-01-17-14-39-55" class="headerlink" title="最后更新时间：2026-01-17 14:39:55"></a><strong>最后更新时间：2026-01-17 14:39:55</strong></h3><hr><h2 id="ArrayPool-概述"><a href="#ArrayPool-概述" class="headerlink" title="ArrayPool 概述"></a>ArrayPool 概述</h2><p>ArrayPool&lt;T&gt; 是 .NET 框架提供的数组对象池类，核心作用是通过复用数组减少内存分配与垃圾回收（GC）开销，提升高性能场景下的程序效率。</p><ul><li><strong>核心特性</strong></li></ul><ol><li>避免重复创建 &#x2F; 销毁数组：针对频繁使用短生命周期数组的场景（如网络传输、数据处理），从对象池获取数组，使用后归还，省去重复分配内存的成本；</li><li>泛型适配：支持任意类型 &lt;T&gt;（如 ArrayPool&lt;int&gt;、ArrayPool&lt;byte&gt;），适配不同数据场景；</li><li>平衡性能与内存：内置默认实现（ArrayPool&lt;T&gt;.Shared），也可自定义池大小、数组上限等配置，避免内存浪费；</li><li>线程安全：默认实现支持多线程并发访问，无需额外加锁。</li></ol><ul><li><strong>核心价值</strong></li></ul><p>解决高频数组操作中“频繁分配 - 回收”导致的 GC 压力，尤其适合高并发、低延迟的应用（如 Web API、缓存服务），是 .NET 性能优化的关键工具之一。</p><p>ArrayPool 类源码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ArrayPool</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ArrayPool</span>()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayPool&lt;T&gt; Shared &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayPool&lt;T&gt; <span class="title">Create</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayPool&lt;T&gt; <span class="title">Create</span>(<span class="params"><span class="built_in">int</span> maxArrayLength, <span class="built_in">int</span> maxArraysPerBucket</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T[] <span class="title">Rent</span>(<span class="params"><span class="built_in">int</span> minimumLength</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Return</span>(<span class="params">T[] array, <span class="built_in">bool</span> clearArray = <span class="literal">false</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ArrayPool-使用教程"><a href="#ArrayPool-使用教程" class="headerlink" title="ArrayPool 使用教程"></a>ArrayPool 使用教程</h2><p>ArrayPool&lt;T&gt; 是.NET 中用于复用数组的工具类，核心只需掌握 Shared 实例、Rent（租借数组）、Return（归还数组） 这三个关键部分：</p><ol><li><strong>核心对象与方法说明</strong></li></ol><ul><li>ArrayPool&lt;T&gt;.Shared：</li></ul><p>是框架提供的默认 ArrayPool 实例，无需手动创建，直接使用即可（也可自定义池配置，一般场景用 Shared 足够）。</p><ul><li><p>Rent(int minimumLength) 方法（租借数组）：</p><ul><li>作用：从对象池里获取一个 <strong>长度 ≥ minimumLength</strong> 的数组（实际长度不确定）；</li><li>返回值：T[] 类型的数组，可直接用于数据操作。</li></ul></li><li><p>Return(T[] array) 方法（归还数组）：</p><ul><li>作用：将租借的数组还回对象池，供后续复用；</li><li>关键参数 clearArray（默认 false）：<ul><li>设为 true：归还前会自动清空数组数据（用 Array.Clear 将所有元素置为默认值，比如 byte 数组会清为 0）；</li><li>设为 false（默认）：数组数据会保留，后续租借者可能读取到旧数据，需自行注意清空。</li></ul></li></ul></li></ul><ol start="2"><li>简单使用示例（以byte数组为例）</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 从默认池租借长度≥256的byte数组（实际返回256长度）</span></span><br><span class="line"><span class="built_in">byte</span>[] buffer = ArrayPool&lt;<span class="built_in">byte</span>&gt;.Shared.Rent(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2. 对数组进行业务操作</span></span><br><span class="line">    buffer[<span class="number">0</span>] = <span class="number">123</span>;</span><br><span class="line">    buffer[<span class="number">1</span>] = <span class="number">234</span>;</span><br><span class="line">    buffer[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// ... 其他数据处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 3. 用完后归还数组（必须执行！否则池资源会泄漏）</span></span><br><span class="line">        <span class="comment">// 若需清空数据，加参数：ArrayPool&lt;byte&gt;.Shared.Return(buffer, clearArray: true)</span></span><br><span class="line">        ArrayPool&lt;<span class="built_in">byte</span>&gt;.Shared.Return(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于 Rent 需不需要 try-catch 的问题，具体请查看：<a href="https://as436845345.github.io/2026/01/17/arraypool-what-you-should-know/">关于 ArrayPool 的你应该了解的内容</a>。</p></blockquote><ol start="3"><li><strong>关键注意事项</strong></li></ol><ul><li>必须归还数组：若租借后不调用 Return，对象池会逐渐耗尽可用数组，失去复用意义；</li><li>数组长度不固定：Rent 返回的数组长度可能大于请求的 minimumLength，操作时需以实际长度为准；</li><li>数据安全问题：默认 Return 不清理数据，若数组存敏感信息，务必加 clearArray: true 清空后再归还。</li></ul><h2 id="为什么尽量使用-ArrayPool-类"><a href="#为什么尽量使用-ArrayPool-类" class="headerlink" title="为什么尽量使用 ArrayPool 类"></a>为什么尽量使用 ArrayPool 类</h2><p>在.NET 中创建数组时，开发者通常会使用 new T[length] 语法，这种方式虽然简单，但在<strong>高频创建 &#x2F; 销毁短生命周期数组</strong>的场景下，会显著影响程序性能 —— 而 ArrayPool&lt;T&gt; 正是为解决这一问题设计的内存复用工具类。</p><h3 id="一、直接用-new-创建数组的性能痛点"><a href="#一、直接用-new-创建数组的性能痛点" class="headerlink" title="一、直接用 new 创建数组的性能痛点"></a>一、直接用 new 创建数组的性能痛点</h3><p>使用 new 创建数组时，CLR（公共语言运行时）会在<strong>托管堆（Managed Heap）</strong>中申请一块连续的内存块，内存大小与数组长度匹配。数组不再被引用后，不会立即释放内存，需等待垃圾回收（GC）触发后才能清理。频繁创建数组时，会带来两大核心性能损耗：</p><ol><li><strong>内存分配耗时增加</strong></li></ol><p>每次用 new 创建数组，CLR 都需要在堆中查找并分配一块符合大小的连续空闲内存：</p><ul><li>单次分配的耗时虽短，但高频操作（如网络 IO、数据流处理中每秒创建数百次数组）会让这部分耗时累积，成为性能瓶颈；</li><li>若堆中无足够连续内存，CLR 还会触发“内存压缩”（GC Compact），进一步阻塞程序执行。</li></ul><ol start="2"><li><strong>垃圾回收（GC）开销飙升</strong></li></ol><ul><li>频繁创建数组会快速消耗堆内存，导致 GC 更频繁触发（尤其是 Gen 0 代回收）；</li><li>GC 执行时会暂停所有托管线程（STW，Stop-The-World），回收越多，程序的响应延迟和 CPU 占用率越高；</li><li>大数组还可能进入 Gen 1&#x2F;Gen 2 代，增加全量垃圾回收的成本（Gen 2 回收耗时远高于 Gen 0）。</li></ul><h3 id="二、ArrayPool-的核心价值：内存复用"><a href="#二、ArrayPool-的核心价值：内存复用" class="headerlink" title="二、ArrayPool&lt;T&gt; 的核心价值：内存复用"></a>二、ArrayPool&lt;T&gt; 的核心价值：内存复用</h3><p>ArrayPool&lt;T&gt; 是 .NET 提供的数组对象池，核心逻辑是“预分配一批数组存于池中，使用时租借（Rent），用完后归还（Return）”，从根本上解决上述问题：</p><ul><li>避免重复分配：从池中租借数组时，直接复用已分配的内存块，无需每次在堆中查找 &#x2F; 申请；</li><li>降低 GC 压力：数组归还后可被再次使用，不会被 GC 回收，减少堆内存占用和 GC 触发频率；</li><li>高性能设计：ArrayPool&lt;T&gt;.Shared 是框架内置的全局默认实例（底层为 SharedArrayPool 类），无需手动创建，开箱即用。</li></ul><h3 id="三、使用建议"><a href="#三、使用建议" class="headerlink" title="三、使用建议"></a>三、使用建议</h3><ol><li>优先使用：在.NET Core 1.0+&#x2F;.NET 5+ 等支持 ArrayPool&lt;T&gt; 的版本中，高频创建短生命周期数组（如字节数组、临时数据缓冲区）时，务必替换为 ArrayPool&lt;T&gt;；</li><li>降级方案：若项目基于不支持 ArrayPool&lt;T&gt; 的旧版本（如.NET Framework 4.x），可参考 GitHub 上 .NET 官方源码，自行实现简化版的数组池（核心逻辑为“维护数组列表，租借时取可用数组，归还时回收”）。</li></ol><h2 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h2><ul><li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.buffers.arraypool-1?view=net-8.0">ArrayPool<T> 类 - Microsoft Learn</a></li><li><a href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Buffers/ArrayPool.cs">ArrayList.cs - Github</a></li><li><a href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Buffers/SharedArrayPool.cs">SharedArrayPool.cs - Github</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Array </tag>
            
            <tag> ArrayPool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>禁止使用 ArrayList 类</title>
      <link href="/2026/01/16/do-not-use-arraylist/"/>
      <url>/2026/01/16/do-not-use-arraylist/</url>
      
        <content type="html"><![CDATA[<h2 id="深入理解-C-ArrayList"><a href="#深入理解-C-ArrayList" class="headerlink" title="深入理解 C# ArrayList"></a>深入理解 C# ArrayList</h2><p>ArrayList 是 C# 中的一个动态列表类，其内部通过维护一个 object 类型的数组 _items 来存储数据。当你调用 Add 方法添加元素时，数据就被存入这个数组中。</p><p>它的存储字段如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">object</span>?[] _items;  <span class="comment">// 存储元素的底层数组</span></span><br></pre></td></tr></table></figure><ul><li><strong>Add 方法的工作原理</strong></li></ul><p>Add 方法负责将元素追加到列表末尾，其参数类型为 object：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">object</span>? <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h2><p>因为 ArrayList 内部存储的是 object 类型（引用类型），当你向其中添加值类型（如 int、char、double）时，会触发 <strong>装箱（boxing）操作；当你从列表中取出值类型时，则会触发拆箱（unboxing）</strong> 操作。</p><ul><li>ArrayList 测试代码</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">M</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    arrayList.Add(<span class="number">1</span>);      <span class="comment">// int 类型值 → 装箱为 object</span></span><br><span class="line">    arrayList.Add(<span class="string">&#x27;a&#x27;</span>);    <span class="comment">// char 类型值 → 装箱为 object</span></span><br><span class="line">    arrayList.Add(<span class="number">3.0</span>);    <span class="comment">// double 类型值 → 装箱为 object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ArrayList 测试代码编译为 IL</li></ul><p>上述 C# 代码编译为 IL 后，我们可以清晰看到装箱的过程：</p><p><img src="/../images/arraylist/arraylist_add_valuetype_il_code.png" alt="ArrayList 测试代码编译为 IL"></p><h2 id="装箱的性能影响"><a href="#装箱的性能影响" class="headerlink" title="装箱的性能影响"></a>装箱的性能影响</h2><p><strong>装箱</strong>是指将值类型转换为引用类型（object）的过程。</p><p>在上面的例子中，添加值类型 1（int）时，IL 会先执行 box [System.Runtime]System.Int32 指令，再调用 Add(object) 方法。这个 box 指令本身会占用 5 个字节的 IL 代码空间（1 字节操作码 + 4 字节元数据令牌），而如果添加的是引用类型，则不会有这个额外开销。</p><p>频繁的装箱 &#x2F; 拆箱会增加内存分配和类型转换的开销，从而影响程序性能。因此在实际开发中，应尽量避免不必要的装箱操作，推荐使用泛型集合（如 List&lt;T&gt;），通过指定具体的存储类型，从根本上避免装箱 &#x2F; 拆箱。</p><h2 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h2><ul><li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/types/">C# 类型系统 - Microsoft Learn</a></li><li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/types/boxing-and-unboxing">装箱和取消装箱（C# 编程指南） - Microsoft Learn</a></li><li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.reflection.emit.opcodes.box?view=net-9.0">IL-box 字段 - Microsoft Learn</a></li><li><a href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Collections/ArrayList.cs">ArrayList.cs - Github</a></li><li><a href="https://sharplab.io/#v2:C4LglgNgPgAgTARgLACgYAYAEMEDoDCA9hBAKYDGwYhAdgM4DcqMAzNnJvpgN6qb/Y2MACyYAsgAoAlDz4D5AQQBOSgIYBPADJg6wTKpUbtuzAF5MNUgHdMytVp3BpTFPPkH7x4LgUATXxIIUi5uAh5Gjj7+EgDkqjHBcqHhDrpRASy46ImuAgC+qHlAA===">测试代码 - sharplab</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Array </tag>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
